(defun arithmetic (&optional (a (read *query-io*)) (b (read *query-io*)))
(mapc
(lambda (op)
(format t "~a => ~a~%" (list op a b) (funcall (symbol-function op) a b)))
'(+ - * mod rem floor ceiling truncate round expt))
(values))
(concatenate 'vector #(0 1 2 3) #(4 5 6 7))
(setf my-hash (make-hash-table :test #'equal))
(setf (gethash "H2O" my-hash) "Water")
(setf (gethash "HCl" my-hash) "Hydrochloric Acid")
(setf (gethash "CO" my-hash) "Carbon Monoxide")
(defparameter *legs* '((cow . 4) (flamingo . 2) (centipede . 100)))
(defun binary-search (value array)
(let ((low 0)
(high (1- (length array))))
(do () ((< high low) nil)
(let ((middle (floor (+ low high) 2)))
(cond ((> (aref array middle) value)
(setf high (1- middle)))
((< (aref array middle) value)
(setf low (1+ middle)))
(t (return middle)))))))
(loop for i from 0 do (format t "~o~%" i))
(defparameter *w* '((a (a b . 7) (a c . 9) (a f . 14))
(b (b c . 10) (b d . 15))
(c (c d . 11) (c f . 2))
(d (d e . 6))
(defvar *r* nil)
(defun dijkstra-short-path (i g)
(setf *r* nil) (paths i g 0 `(,i))
(car (sort *r* #'< :key #'cadr)))
(defun paths (c g z v)
(if (eql c g) (push `(,(reverse v) ,z) *r*)
(loop for a in (nodes c) for b = (cadr a) do
(unless (member b v)
(paths b g (+ (cddr a) z) (cons b v))))))
(defun nodes (c)
(sort (cdr (assoc c *w*)) #'< :key #'cddr))
(defun factorial (n)
(if (zerop n) 1 (* n (factorial (1- n)))))
(defun fizzbuzz ()
(loop for x from 1 to 100 do
(princ (cond ((zerop (mod x 15)) "FizzBuzz")
((zerop (mod x 3))  "Fizz")
((zerop (mod x 5))  "Buzz")
(terpri)))
(rotatef a b)
(psetq a b b a)
CL-USER> (gcd 2345 5432)
7
(defstruct huffman-node
(weight 0 :type number)
(element nil :type t)
(encoding nil :type (or null bit-vector))
(left nil :type (or null huffman-node))
(right nil :type (or null huffman-node)))
(defun initial-huffman-nodes (sequence &key (test 'eql))
(let* ((length (length sequence))
(increment (/ 1 length))
(nodes (make-hash-table :size length :test test))
(queue '()))
(map nil #'(lambda (element)
(multiple-value-bind (node presentp) (gethash element nodes)
(if presentp
(incf (huffman-node-weight node) increment)
(let ((node (make-huffman-node :weight increment
:element element)))
(setf (gethash element nodes) node
queue (list* node queue))))))
sequence)
(values nodes (sort queue '< :key 'huffman-node-weight))))
(defun huffman-tree (sequence &key (test 'eql))
(multiple-value-bind (nodes queue)
(initial-huffman-nodes sequence :test test)
(do () ((endp (rest queue)) (values nodes (first queue)))
(destructuring-bind (n1 n2 &rest queue-rest) queue
(let ((n3 (make-huffman-node
:left n1
:right n2
:weight (+ (huffman-node-weight n1)
(huffman-node-weight n2)))))
(setf queue (merge 'list (list n3) queue-rest '<
:key 'huffman-node-weight)))))))1
(defun huffman-codes (sequence &key (test 'eql))
(multiple-value-bind (nodes tree)
(huffman-tree sequence :test test)
(labels ((hc (node length bits)
(let ((left (huffman-node-left node))
(right (huffman-node-right node)))
(cond
((and (null left) (null right))
(setf (huffman-node-encoding node)
(make-array length :element-type 'bit
:initial-contents (reverse bits))))
(t (hc left (1+ length) (list* 0 bits))
(hc right (1+ length) (list* 1 bits)))))))
(hc tree 0 '())
nodes)))
(defun print-huffman-code-table (nodes &optional (out *standard-output*))
(format out "~&Element~10tWeight~20tCode")
(loop for node being each hash-value of nodes
do (format out "~&~s~10t~s~20t~s"
(huffman-node-element node)
(huffman-node-weight node)
(huffman-node-encoding node))))
(loop for i from 1 upto 5 do
(loop for j from 1 upto i do
(write-char #\*))
(terpri))
(let ((i 1024))
(loop while (plusp i) do
(print i)
(setf i (floor i 2))))
(loop with i = 1024
while (plusp i) do
(print i)
(setf i (floor i 2)))
(defparameter *i* 1024)
(loop while (plusp *i*) do
(print *i*)
(setf *i* (floor *i* 2)))
(defun merge-sort (result-type sequence predicate)
(let ((split (floor (length sequence) 2)))
(if (zerop split)
(copy-seq sequence)
(merge result-type (merge-sort result-type (subseq sequence 0 split) predicate)
(merge-sort result-type (subseq sequence split)   predicate)
predicate))))
(do ((m 0 (if (= 12 m) 0 (1+ m)))
(n 0 (if (= 12 m) (1+ n) n)))
((= n 13))
(if (zerop n)
(case m
(0 (format t "  *|"))
(otherwise
(format t "~4,D" m)))
(case m
(0 (format t "~3,D|" n))
(12 (format t "~4,D~&" (* n m)))
(otherwise
(if (>= m n)
(format t "~4,D" (* m n))
(format t "    "))))))
(defun palindrome-p (s)
(string= s (reverse s)))
(defun factor (n)
"Return a list of factors of N."
(when (> n 1)
(loop with max-d = (isqrt n)
for d = 2 then (if (evenp d) (+ d 1) (+ d 2)) do
(cond ((> d max-d) (return (list n)))
((zerop (rem n d)) (return (cons d (factor (truncate n d)))))))))
(defun quicksort (list &aux (pivot (car list)) )
(if (cdr list)
(nconc (quicksort (remove-if-not #'(lambda (x) (< x pivot)) list))
(remove-if-not #'(lambda (x) (= x pivot)) list)
(quicksort (remove-if-not #'(lambda (x) (> x pivot)) list)))
list))
(let ((string "I am a string"))
(when (cl-ppcre:scan "string$" string)
(write-line "Ends with string"))
(unless (cl-ppcre:scan "^You" string )
(write-line "Does not start with 'You'")))
(defun reverse-string (value)
"Reverse the string `value`. Handle wide characters with care."
(labels ((combining-char-p (c)
(eql :nsm (sb-unicode:bidi-class c)))
(%reverse (chars group acc)
(cond ((endp chars)
(coerce (append (nreverse group) acc) 'string))
((combining-char-p (first chars))
(%reverse (rest chars)
(cons (first chars) group)
acc))
(t (%reverse (rest chars)
(list (first chars))
(append (nreverse group) acc))))))
(%reverse (coerce value 'list) nil nil)))
(let ((s "hello"))
(format t "~a there!~%" s)
(let* ((s2 " there!")
(s (concatenate 'string s s2)))
(format t "~a~%" s)))
(let ((data #(1 2 3 4 5)))
(values (reduce #'+ data)
(reduce #'* data)))
(defun move (n from to via)
(cond ((= n 1)
(format t "Move from ~A to ~A.~%" from to))
(t
(move (- n 1) from via to)
(format t "Move from ~A to ~A.~%" from to)
(move (- n 1) via to from))))