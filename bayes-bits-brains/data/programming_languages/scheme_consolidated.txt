(define (sing)
(define (sing-to-x n)
(if (> n -1)
(begin
(display n)
(display "bottles of beer on the wall")
(newline)
(display "Take one down, pass it around")
(newline)
(sing-to-x (- n 1)))
(display "would you wanna me to sing it again?")))
(sing-to-x 99))
(define (arithmetic x y)
(for-each (lambda (op)
(write  (list op x y))
(display " => ")
(write ((eval op) x y))
(newline))
'(+ - * / quotient remainder modulo max min gcd lcm)))
(arithmetic 8 12)
(define (vector-append . arg) (list->vector (apply append (map vector->list arg))))
(vector-append #(1 2 3 4) #(5 6 7) #(8 9 10))
(define my-dict '((a b) (1 hello) ("c" (a b c)))
(assoc 'a my-dict)
(define (binary-search value vector)
(let helper ((low 0)
(high (- (vector-length vector) 1)))
(if (< high low)
#f
(let ((middle (quotient (+ low high) 2)))
(cond ((> (vector-ref vector middle) value)
(helper low (- middle 1)))
((< (vector-ref vector middle) value)
(helper (+ middle 1) high))
(else middle))))))
(cond-expand
(chicken (use srfi-13))
(gauche  (use srfi-13))
(kawa    (import (srfi :13)))
(else    (import (scheme base) (scheme write))))
(define msg "The quick brown fox jumps over the lazy dog.")
(define key 13)
(define (caesar char)
(define A (char->integer #\A))
(define Z (char->integer #\Z))
(define a (char->integer #\a))
(define z (char->integer #\z))
(define c (char->integer char))
(integer->char
(cond ((<= A c Z) (+ A (modulo (+ key (- c A)) 26)))
((<= a c z) (+ a (modulo (+ key (- c a)) 26)))
(else c))))
(display (string-map caesar msg))
(newline)
(do ((i 0 (+ i 1))) (#f) (display (number->string i 8)) (newline))
(do ((i 1 (+ i 1)))
(display
(cond ((= 0 (modulo i 15)) "FizzBuzz")
((= 0 (modulo i 3))  "Fizz")
((= 0 (modulo i 5))  "Buzz")
(newline))
(define (multiply a b)
(* a b))
(define (vector-swap! v i j)
(let ((a (vector-ref v i)) (b (vector-ref v j)))
(vector-set! v i b)
(vector-set! v j a)))
(let ((vec (vector 1 2 3 4 5)))
(vector-swap! vec 0 4)
vec)
(define (list-swap! v i j)
(let* ((x (list-tail v i))
(y (list-tail v j))
(a (car x))
(b (car y)))
(set-car! x b)
(set-car! y a)))
(let ((lis (list 1 2 3 4 5)))
(list-swap! lis 0 4)
lis)
(define-syntax swap!
(syntax-rules ()
((_ a b)
(let ((tmp a))
(set! a b)
(set! b tmp)))))
(let ((a 1) (b 2)) (swap! a b) (list a b))
(define (gcd a b)
(if (= b 0)
a
(gcd b (modulo a b))))
(define (char-freq port table)
(if
(eof-object? (peek-char port))
table
(char-freq port (add-char (read-char port) table))))
(define (add-char char table)
(cond
((null? table) (list (list char 1)))
((eq? (caar table) char) (cons (list char (+ (cadar table) 1)) (cdr table)))
(#t (cons (car table) (add-char char (cdr table))))))
(define (nodeify table)
(map (lambda (x) (list x '() '())) table))
(define node-freq cadar)
(define (huffman-tree nodes)
(let ((queue (sort nodes (lambda (x y) (< (node-freq x) (node-freq y))))))
(if
(null? (cdr queue))
(car queue)
(huffman-tree
(cons
(list
(list 'notleaf (+ (node-freq (car queue)) (node-freq (cadr queue))))
(car queue)
(cadr queue))
(cddr queue))))))
(define (list-encodings tree chars)
(for-each (lambda (c) (format #t "~a:~a~%" c (encode c tree))) chars))
(define (encode char tree)
(cond
((null? tree) #f)
((eq? (caar tree) char) '())
(#t
(let ((left (encode char (cadr tree))) (right (encode char (caddr tree))))
(cond
((not (or left right)) #f)
(left (cons #\1 left))
(right (cons #\0 right)))))))
(define (decode digits tree)
(cond
((not (eq? (caar tree) 'notleaf)) (caar tree))
((eq? (car digits) #\0) (decode (cdr digits) (cadr tree)))
(#t (decode (cdr digits) (caddr tree)))))
(define input "this is an example for huffman encoding")
(define freq-table (char-freq (open-input-string input) '()))
(define tree (huffman-tree (nodeify freq-table)))
(list-encodings tree (map car freq-table))
(do ((i 1 (+ i 1)))
((> i 5))
(do ((j 1 (+ j 1)))
((> j i))
(display "*"))
(newline))
(do ((n 1024 (quotient n 2)))
((<= n 0))
(display n)
(newline))
(define (merge-sort l gt?)
(define (merge left right)
(cond
((null? left)
right)
((null? right)
left)
((gt? (car left) (car right))
(cons (car right)
(merge left (cdr right))))
(else
(cons (car left)
(merge (cdr left) right)))))
(define (take l n)
(if (zero? n)
(list)
(cons (car l)
(take (cdr l) (- n 1)))))
(let ((half (quotient (length l) 2)))
(if (zero? half)
l
(merge (merge-sort (take      l half) gt?)
(merge-sort (list-tail l half) gt?)))))
(define iota
(lambda (count start step)
(let loop ((result (list (+ start (* (- count 1) step)))))
(let ((acc (car result)))
(if (= acc start)
result
(loop (cons (- acc step) result)))))))
(define table
(lambda (x)
(let loop ((count 1)
(numbers (iota x 1 1)))
(if (not (null? numbers))
(begin
(display (make-string (* 6 (- count 1)) #\space))
(for-each
(lambda (n)
(let ((number (number->string (* n count))))
(display (string-append
(make-string (- 6 (string-length number)) #\space)
number))))
numbers)
(newline)
(loop (+ count 1)
(cdr numbers)))))))
(define (palindrome? s)
(let ((chars (string->list s)))
(equal? chars (reverse chars))))
(define (factor number)
(define (*factor divisor number)
(if (> (* divisor divisor) number)
(list number)
(if (= (modulo number divisor) 0)
(cons divisor (*factor divisor (/ number divisor)))
(*factor (+ divisor 1) number))))
(*factor 2 number))
(display (factor 111111111111))
(newline)
(define (string-reverse s)
(list->string (reverse (string->list s))))
(define s "hello")
(display (string-append s " literal"))
(newline)
(define s1 (string-append s " literal"))
(display s1)
(newline)
(apply + '(1 2 3 4 5))
(apply * '(1 2 3 4 5))
(define (towers-of-hanoi n from to spare)
(define (print-move from to)
(display "Move[")
(display from)
(display ", ")
(display to)
(display "]")
(newline))
(cond ((= n 0) "done")
(else
(towers-of-hanoi (- n 1) from spare to)
(print-move from to)
(towers-of-hanoi (- n 1) spare to from))))
(towers-of-hanoi 3 "A" "B" "C")