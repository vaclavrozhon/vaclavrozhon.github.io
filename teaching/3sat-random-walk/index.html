---
layout: single
title: Random Walk for 3SAT — Markov Chain Demo
permalink: "/teaching/3sat-random-walk/"
katex: false
author_profile: false
---

<style>
:root{
  /* Light as default to match other demos */
  --bg: #f6f8ff;
  --panel: #ffffff;
  --muted: #5b6477;
  --text: #0c1020;
  --accent: #2c6dff;
  --accent-2:#1a936f;
  --good: #1f8a4c;
  --bad:  #c0392b;
  --warn: #b8860b;
  --chip: #f3f6ff;
  --chip-border: #e4e9ff;
  --ring: rgba(44,109,255,.18);
}

@media (prefers-color-scheme: dark){
  :root{
    --bg: #0b0d12;
    --panel: #121621;
    --muted: #8b93a7;
    --text: #e7ebff;
    --accent: #7aa2ff;
    --accent-2:#9bdeac;
    --good: #2ecc71;
    --bad:  #ff6b6b;
    --warn: #ffd166;
    --chip: #1b2233;
    --chip-border: #2a3347;
    --ring: rgba(122,162,255,.25);
  }
}

.three-sat-container {
  max-width: 1100px; margin: 0 auto; color: var(--text);
}

.hero {
  background: radial-gradient(1200px 400px at 20% -10%, rgba(122,162,255,.12), transparent),
              radial-gradient(800px 300px at 90% 10%, rgba(155,222,172,.12), transparent);
  border: 1px solid var(--chip-border);
  background-color: var(--panel);
  border-radius: 16px; padding: 24px; margin-bottom: 16px;
  box-shadow: 0 10px 30px rgba(0,0,0,.15);
}

.hero h2 { margin: 0 0 6px; letter-spacing: .2px; }
.hero p  { margin: 0; color: var(--muted); }

.badges { display:none; gap:8px; flex-wrap: wrap; margin-top: 12px; }
.badge { font-size:.85rem; padding:4px 10px; border-radius:999px; background:var(--chip); border:1px solid var(--chip-border); color:var(--muted); }

.controls {
  display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0 0.75rem;
}
.controls textarea {
  width: 100%; min-height: 140px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  font-size: .9rem; line-height: 1.35; color: var(--text); background: var(--panel);
  border: 1px solid var(--chip-border); border-radius: 12px; padding: 10px 12px;
  outline: none; box-shadow: inset 0 0 0 2px transparent;
}
.controls textarea:focus { box-shadow: inset 0 0 0 2px var(--ring); }

.field label { font-weight: 600; margin-bottom: 6px; color: var(--muted); }

.controls-row {
  display:flex; align-items:center; gap:10px; flex-wrap: wrap; margin-top: 6px;
}

button {
  appearance: none; border:1px solid var(--chip-border); background: linear-gradient(180deg, var(--panel), rgba(0,0,0,.02));
  color: var(--text); padding: 8px 12px; border-radius: 10px; font-weight:600; letter-spacing:.2px;
  transition: transform .05s ease, box-shadow .2s ease, border-color .2s ease;
  box-shadow: 0 2px 0 rgba(0,0,0,.12);
}
button:hover { border-color: var(--ring); box-shadow: 0 4px 16px rgba(0,0,0,.15), 0 0 0 4px var(--ring); }
button:active { transform: translateY(1px); box-shadow: 0 1px 0 rgba(0,0,0,.2); }

.btn-primary { background: linear-gradient(180deg, var(--accent), #5d87ff); color:#fff; border-color: transparent; }
.btn-ghost  { background: transparent; }

.input-inline{
  display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid var(--chip-border);
  border-radius:10px; background:var(--panel); color:var(--muted);
}
.input-inline input[type="text"]{ border:none; outline:none; background:transparent; color:var(--text); width:8rem; }

.status { margin: 8px 0 12px; font-size: .95rem; color: var(--muted); }
.status .ok    { color: var(--good); font-weight:600; }
.status .warn  { color: var(--bad);  font-weight:600; }
.status.pending { color: var(--warn); font-weight:600; }

.card {
  border: 1px solid var(--chip-border); border-radius: 16px; padding: 14px 16px; background: var(--panel);
}

.hidden { display: none; }

/* Hide site chrome to make this a standalone demo */
.masthead, .page__footer, .page__meta, .author__sidebar, .sidebar, .breadcrumbs, .page__hero { display: none !important; }
.initial-content { padding-top: 0 !important; }

.viz .section-title{ display:flex; align-items:baseline; justify-content:space-between; gap:12px; }
.progress {
  height: 6px; background: var(--chip); border: 1px solid var(--chip-border);
  border-radius: 999px; overflow: hidden;
}
.progress > div { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); width: 0%; transition: width .35s ease; }

.clauses { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 6px; margin-top: 8px; max-height: 260px; overflow: auto; }
.clause {
  padding: 6px 8px; border-radius: 10px; border: 1px solid var(--chip-border);
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  background: var(--chip); position: relative; font-size: .85rem;
}
.clause .dot{
  position:absolute; top:10px; right:10px; width:10px; height:10px; border-radius:50%;
  box-shadow: 0 0 0 4px rgba(0,0,0,.04);
}
.clause.sat   { background: rgba(46, 204, 113, .09); border-color: rgba(46, 204, 113, .35); }
.clause.sat .dot{ background: var(--good); }
.clause.unsat { background: rgba(255, 107, 107, .08); border-color: rgba(255, 107, 107, .35); }
.clause.unsat .dot{ background: var(--bad); }
.clause.selected { font-weight: 700; border-color: var(--accent); box-shadow: 0 0 0 4px var(--ring), 0 6px 16px rgba(0,0,0,.12); }

.assignments { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 6px; margin-top: 10px; }
.assignment {
  padding: 6px 8px; border: 1px solid var(--chip-border); border-radius: 10px; background: var(--chip);
  display:flex; align-items:center; gap:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:.9rem;
}
.assignment .status-dot{ width:8px; height:8px; border-radius:50%; box-shadow: 0 0 0 3px rgba(0,0,0,.04); border: 1px solid rgba(0,0,0,.1); }
.assignment .status-dot.match{ background: #2ecc71; }
.assignment .status-dot.mismatch{ background: #ff6b6b; }

.chain { margin-top: 16px; }
.chain svg { width: 100%; height: 170px; }
.legend { font-size: .9rem; color: var(--muted); margin-top: 8px; }

.small { font-size: .9rem; color: var(--muted); }
.kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background: var(--chip); border: 1px solid var(--chip-border); padding: 2px 6px; border-radius: 6px; }

.footer-note{
  margin-top: 18px; padding: 14px 16px; border-left: 4px solid var(--accent); background: linear-gradient(90deg, rgba(122,162,255,.06), transparent);
  border-radius: 12px; color: var(--muted);
}
</style>

<div class="three-sat-container">
  <div class="hero">
    <h2>Random Walk for 3SAT</h2>
    <p>At each step: pick a uniformly random unsatisfied clause, then flip a uniformly random variable from it. Track the Hamming agreement with a fixed satisfying assignment, visualized as a 1-D Markov chain on states <span class="kbd">0..n</span>.</p>
    <div class="badges">
      <span class="badge" id="badgeN">n = –</span>
      <span class="badge" id="badgeM">m = –</span>
      <span class="badge" id="badgeAgree">agreement h = –/–</span>
      <span class="badge" id="badgeSteps">steps = 0</span>
    </div>
  </div>

  <div class="controls hidden" id="editorPanel">
    <div class="field">
      <label for="cnfInput">DIMACS CNF <span class="small">(≤ 20 variables)</span></label>
      <textarea id="cnfInput"></textarea>
    </div>
    <div class="field">
      <label for="fixedInput">Fixed satisfying assignment <span class="small">(optional; 0/1 or ±1, space-separated). Leave empty to auto-solve.</span></label>
      <textarea id="fixedInput" placeholder="e.g. 1 0 1 1 0"></textarea>
    </div>
    <div class="controls-row">
      <button id="btnDone" class="btn-ghost">Done</button>
    </div>
  </div>

  <div class="controls-row">
    <button id="btnStep">Step</button>
    <button id="btnPlay">Play</button>
    <button id="btnRestart" class="btn-ghost">Restart random</button>
    <button id="btnToggleControls" class="btn-ghost" title="Show/Hide instance editor">Change instance</button>
    <span class="input-inline">Speed <input id="speedInput" type="range" min="40" max="1000" step="20" value="240"></span>
  </div>

  <div class="status" id="status"></div>

  <div class="card viz">
    <div class="section-title">
      <div><strong>Clauses</strong></div>
      <div style="flex:1; margin-left:12px;">
        <div class="progress" title="Fraction of satisfied clauses under current working assignment">
          <div id="satProgress" style="width:0%"></div>
        </div>
      </div>
    </div>
    <div class="clauses" id="clauses"></div>
    <div class="assignments" id="assignments"></div>
  </div>

  <div class="card viz chain">
    <div class="section-title">
      <div><strong>Agreement with fixed assignment</strong> <span class="small">nodes 0..n</span></div>
      <div class="small" id="probLabel"></div>
    </div>
    <svg id="chainSvg" viewBox="0 0 1000 170" preserveAspectRatio="xMidYMid meet" aria-label="Hamming agreement chain"></svg>
    <div class="legend">After selecting a clause with <span class="kbd">k</span> literals matching the fixed assignment, the step goes “towards” the fixed solution with probability <span class="kbd">(3−k)/3</span> and “away” with probability <span class="kbd">k/3</span>.</div>
  </div>

  <div class="footer-note">
    <strong>Context.</strong> This walk is the core move used in local-search SAT solvers (e.g. WalkSAT) and also appears in theoretical algorithms. A classic example is <em>Schöning’s algorithm</em> for 3-SAT, which repeatedly performs short random walks on the Hamming cube and achieves a running time of the form \(c^n\) with \(c&lt;1.5\) (details in the article). For current best asymptotic bounds (e.g. PPSZ-type refinements), see the references therein.  
    <br/>Learn more on Wikipedia: <a href="https://en.wikipedia.org/wiki/Sch%C3%B6ning%27s_algorithm">Schöning’s algorithm</a> and the overview at <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">Boolean satisfiability problem</a>.
  </div>
</div>

<script>
// ---------- Utilities ----------
function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;let t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return ((t^t>>>14)>>>0)/4294967296}}
function hashStringToSeed(str){let h=2166136261>>>0;for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=Math.imul(h,16777619)}return h>>>0}

// ---------- DIMACS parsing & SAT eval ----------
function parseDimacs(text){
  const lines = text.split(/\r?\n/);
  const clauses = [];
  let declaredN = null, declaredM = null;
  for (const raw of lines){
    const line = raw.trim();
    if (!line || line.startsWith('c')) continue;
    if (line.startsWith('p')){
      const parts = line.split(/\s+/);
      if (parts.length>=4 && parts[1].toLowerCase()==='cnf'){
        declaredN = parseInt(parts[2],10);
        declaredM = parseInt(parts[3],10);
      }
      continue;
    }
    const nums = line.split(/\s+/).map(x=>parseInt(x,10)).filter(x=>!Number.isNaN(x));
    let clause = [];
    for (const v of nums){ if (v===0) break; clause.push(v); }
    if (clause.length>0) clauses.push(clause);
  }
  let n=0; for (const c of clauses) for (const lit of c) n=Math.max(n,Math.abs(lit));
  if (declaredN!==null) n = Math.max(n, declaredN);
  return { n, clauses };
}
function evalClause(clause, a){
  for (const lit of clause){
    const i = Math.abs(lit)-1, isPos = lit>0;
    const v = a[i];
    if ((isPos && v) || (!isPos && !v)) return true;
  }
  return false;
}
function evalFormula(clauses, a){ return clauses.every(c=>evalClause(c,a)); }

// Small backtracking solver (n ≤ 20)
function solveSAT(n, clauses){
  const a = new Array(n).fill(false);
  function dfs(i){
    if (i===n) return evalFormula(clauses,a) ? a.slice() : null;
    for (let bit=0; bit<2; bit++){
      a[i] = !!bit;
      let ok = true;
      for (const cl of clauses){
        let canTrue = false;
        for (const lit of cl){
          const idx = Math.abs(lit)-1, isPos = lit>0;
          if (idx>i){ canTrue=true; break; }
          if ((isPos && a[idx]) || (!isPos && !a[idx])){ canTrue=true; break; }
        }
        if (!canTrue){ ok=false; break; }
      }
      if (ok){ const r = dfs(i+1); if (r) return r; }
    }
    return null;
  }
  return dfs(0);
}
function parseFixedAssignment(text,n){
  if (!text || !text.trim()) return null;
  const t = text.trim().split(/\s+/);
  if (t.length<n) return null;
  const arr=[];
  for (let i=0;i<n;i++){
    const s=t[i];
    if (s==='1'||s==='+1'||s==='+') arr.push(true);
    else if (s==='0'||s==='-1'||s==='-') arr.push(false);
    else return null;
  }
  return arr;
}

// ---------- DOM ----------
const elCNF = document.getElementById('cnfInput');
const elFixed = document.getElementById('fixedInput');
const elStatus = document.getElementById('status');
const elClauses = document.getElementById('clauses');
const elAssignments = document.getElementById('assignments');
const elProb = document.getElementById('probLabel');
const svg = document.getElementById('chainSvg');
const elProg = document.getElementById('satProgress');

const btnStep = document.getElementById('btnStep');
const btnPlay = document.getElementById('btnPlay');
const btnRestart = document.getElementById('btnRestart');
const btnToggleControls = document.getElementById('btnToggleControls');
const editorPanel = document.getElementById('editorPanel');
const elSpeed = document.getElementById('speedInput');
const btnDone = document.getElementById('btnDone');

const badgeN = document.getElementById('badgeN');
const badgeM = document.getElementById('badgeM');
const badgeAgree = document.getElementById('badgeAgree');
const badgeSteps = document.getElementById('badgeSteps');

// ---------- State ----------
let n=0, clauses=[], fixed=null, working=null;
let rng = Math.random, playing=false, timer=null, substep=0;
let selectedClauseIndex = -1, hammingAgree=0, stepCount=0, dirty=false;

// ---------- Helpers ----------
function setStatus(html, okState){
  elStatus.innerHTML = html;
  elStatus.className = 'status ' + (okState===true ? 'ok' : okState===false ? 'warn' : '');
}
function setPendingMessage(){
  elStatus.innerHTML = 'Changes pending. Click <b>Load instance</b> to apply.';
  elStatus.className = 'status pending';
}
function countAgree(a,b){ let h=0; for(let i=0;i<a.length;i++) if(a[i]===b[i]) h++; return h; }
function updateBadges(){
  badgeN.textContent = `n = ${n||'–'}`;
  badgeM.textContent = `m = ${clauses.length||'–'}`;
  badgeAgree.textContent = fixed ? `agreement h = ${hammingAgree}/${n}` : 'agreement h = –/–';
  badgeSteps.textContent = `steps = ${stepCount}`;
}
function updateProgressBar(){
  if (!working) { elProg.style.width='0%'; return; }
  const sat = clauses.reduce((s,c)=>s+(evalClause(c,working)?1:0),0);
  const pct = clauses.length? Math.round(100*sat/clauses.length):0;
  elProg.style.width = pct + '%';
  elProg.title = `${sat}/${clauses.length} clauses satisfied`;
}

function renderAssignments(){
  elAssignments.innerHTML = '';
  if (!fixed || !working) return;
  for (let i=0;i<n;i++){
    const row = document.createElement('div');
    row.className = 'assignment';
    const dot = document.createElement('span');
    const isMatch = (working[i]===fixed[i]);
    dot.className = 'status-dot ' + (isMatch ? 'match' : 'mismatch');
    dot.title = isMatch ? 'matches fixed' : 'differs from fixed';
    const text = document.createElement('span');
    text.innerHTML = `x${i+1} = <b>${working[i]?1:0}</b>`;
    row.appendChild(dot);
    row.appendChild(text);
    elAssignments.appendChild(row);
  }
}

function renderClauses(){
  elClauses.innerHTML = '';
  const unsat=[];
  for (let i=0;i<clauses.length;i++){
    const sat = evalClause(clauses[i], working);
    if (!sat) unsat.push(i);
    const d = document.createElement('div');
    d.className = 'clause ' + (sat?'sat':'unsat') + (i===selectedClauseIndex?' selected':'');
    d.textContent = '(' + clauses[i].map(l=> l>0? `x${l}` : `¬x${-l}`).join(' ∨ ') + ')';
    elClauses.appendChild(d);
  }
  updateProgressBar();
  return unsat;
}

function renderChain(){
  svg.innerHTML = '';
  if (!fixed) return;
  const width = svg.viewBox.baseVal.width, height = svg.viewBox.baseVal.height;
  const padX = 40, y = 86, R = 15, nodeCount = n+1, usable = width - 2*padX, stepX = nodeCount>1 ? usable/(nodeCount-1) : 0;

  const axis = document.createElementNS('http://www.w3.org/2000/svg','line');
  axis.setAttribute('x1', padX); axis.setAttribute('y1', y);
  axis.setAttribute('x2', width-padX); axis.setAttribute('y2', y);
  axis.setAttribute('stroke', '#3a4561'); axis.setAttribute('stroke-width','2');
  svg.appendChild(axis);

  for (let i=0;i<nodeCount;i++){
    const cx = padX + i*stepX;
    // connectors
    if (i<nodeCount-1){
      const seg = document.createElementNS('http://www.w3.org/2000/svg','line');
      seg.setAttribute('x1', cx+R); seg.setAttribute('y1', y);
      seg.setAttribute('x2', cx+stepX-R); seg.setAttribute('y2', y);
      seg.setAttribute('stroke', '#3a4561'); seg.setAttribute('stroke-width','2');
      svg.appendChild(seg);
    }
    // node
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('cx', cx); circle.setAttribute('cy', y); circle.setAttribute('r', R);
    circle.setAttribute('fill', i===hammingAgree ? 'url(#gradActive)' : '#1b2233');
    circle.setAttribute('stroke', i===hammingAgree ? '#89a7ff' : '#2a3347');
    circle.setAttribute('stroke-width', i===hammingAgree ? '2.5' : '1.5');
    g.appendChild(circle);

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', cx); label.setAttribute('y', y+33);
    label.setAttribute('text-anchor','middle'); label.setAttribute('font-size','12');
    label.setAttribute('fill','#8b93a7'); label.textContent = i;
    g.appendChild(label);

    svg.appendChild(g);
  }

  // defs for gradient
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  const grad = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
  grad.setAttribute('id','gradActive'); grad.setAttribute('x1','0'); grad.setAttribute('x2','1');
  const s1 = document.createElementNS('http://www.w3.org/2000/svg','stop'); s1.setAttribute('offset','0%'); s1.setAttribute('stop-color','#7aa2ff');
  const s2 = document.createElementNS('http://www.w3.org/2000/svg','stop'); s2.setAttribute('offset','100%'); s2.setAttribute('stop-color','#9bdeac');
  grad.appendChild(s1); grad.appendChild(s2); defs.appendChild(grad); svg.appendChild(defs);

  // arrowhead marker for probability arrows
  const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
  marker.setAttribute('id','arrowHead');
  marker.setAttribute('markerWidth','8');
  marker.setAttribute('markerHeight','8');
  marker.setAttribute('refX','8');
  marker.setAttribute('refY','4');
  marker.setAttribute('orient','auto');
  marker.setAttribute('markerUnits','strokeWidth');
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('d','M0,0 L8,4 L0,8 Z');
  path.setAttribute('fill','#2c6dff');
  marker.appendChild(path);
  defs.appendChild(marker);
}

function updateProbLabel(k){
  // Draw probability arrows above adjacent edges; clear when k is null
  const existing = svg.querySelector('#probArrows');
  if (existing) existing.remove();
  if (k==null || !fixed) { elProb.textContent = ''; return; }
  elProb.textContent = '';

  const width = svg.viewBox.baseVal.width;
  const padX = 40, y = 86, R = 15;
  const nodeCount = n + 1;
  const usable = width - 2*padX;
  const stepX = nodeCount>1 ? usable/(nodeCount-1) : 0;

  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  g.setAttribute('id','probArrows');

  const arrowY = y - 26;
  const labelY = arrowY - 6;
  const color = '#2c6dff';

  // left edge: away = k/3
  if (hammingAgree > 0){
    const x1 = padX + (hammingAgree-1)*stepX + R;
    const x2 = padX + hammingAgree*stepX - R;
    const mid = (x1 + x2) / 2;
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', (mid+18));
    line.setAttribute('y1', arrowY);
    line.setAttribute('x2', (mid-18));
    line.setAttribute('y2', arrowY);
    line.setAttribute('stroke', color);
    line.setAttribute('stroke-width','2');
    line.setAttribute('marker-end','url(#arrowHead)');
    g.appendChild(line);
    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x', mid);
    text.setAttribute('y', labelY);
    text.setAttribute('text-anchor','middle');
    text.setAttribute('font-size','12');
    text.setAttribute('fill', color);
    text.textContent = `${k}/3`;
    g.appendChild(text);
  }

  // right edge: toward = (3-k)/3
  if (hammingAgree < n){
    const x1 = padX + hammingAgree*stepX + R;
    const x2 = padX + (hammingAgree+1)*stepX - R;
    const mid = (x1 + x2) / 2;
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', (mid-18));
    line.setAttribute('y1', arrowY);
    line.setAttribute('x2', (mid+18));
    line.setAttribute('y2', arrowY);
    line.setAttribute('stroke', color);
    line.setAttribute('stroke-width','2');
    line.setAttribute('marker-end','url(#arrowHead)');
    g.appendChild(line);
    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x', mid);
    text.setAttribute('y', labelY);
    text.setAttribute('text-anchor','middle');
    text.setAttribute('font-size','12');
    text.setAttribute('fill', color);
    text.textContent = `${3-k}/3`;
    g.appendChild(text);
  }

  svg.appendChild(g);
}

function selectUnsatisfiedClause(){
  const unsat=[]; for (let i=0;i<clauses.length;i++) if(!evalClause(clauses[i],working)) unsat.push(i);
  if (!unsat.length) return -1;
  return unsat[Math.floor(rng()*unsat.length)];
}

function substepSelectClause(){
  selectedClauseIndex = selectUnsatisfiedClause();
  if (selectedClauseIndex===-1){
    setStatus('<span class="ok">All clauses satisfied — solution reached.</span>', true);
    playing=false; btnPlay.textContent='Play'; updateProbLabel(null); return;
  }
  const clause = clauses[selectedClauseIndex];
  let k=0;
  for (const lit of clause){
    const idx = Math.abs(lit)-1;
    if (working[idx]===fixed[idx]) k++;
  }
  updateProbLabel(k);
  renderClauses();
}

function substepFlipVariable(){
  if (selectedClauseIndex<0) return;
  const clause = clauses[selectedClauseIndex];
  const pick = clause[Math.floor(rng()*clause.length)];
  const v = Math.abs(pick)-1;
  const before = (working[v]===fixed[v]);
  working[v] = !working[v];
  const after = (working[v]===fixed[v]);
  if (before && !after) hammingAgree--;
  else if (!before && after) hammingAgree++;
  stepCount++; selectedClauseIndex=-1; updateProbLabel(null);
  renderClauses(); renderAssignments(); renderChain(); updateBadges();
}

function doStep(){ if (substep===0){ substepSelectClause(); substep=1; } else { substepFlipVariable(); substep=0; } }

function setSeedDefault(){ rng = Math.random; }

function restartWorkingAssignment(randomize=true){
  if (!fixed) return;
  if (randomize){ working = new Array(n).fill(false).map(()=>rng()<.5); }
  else { working = fixed.slice(); }
  hammingAgree = countAgree(working, fixed);
  substep=0; selectedClauseIndex=-1; stepCount=0;
  renderAssignments(); renderClauses(); renderChain(); updateBadges();
  setStatus(`number of variables = ${n}, number of clauses = ${clauses.length}`, true);
}

function loadInstance(){
  const parsed = parseDimacs(elCNF.value);
  n = parsed.n; clauses = parsed.clauses;
  if (n<=0 || n>20){
    setStatus('<span class="warn">Invalid or too large instance. Require 1 ≤ n ≤ 20.</span>', false);
    return;
  }
  const manual = parseFixedAssignment(elFixed.value, n);
  fixed = manual || solveSAT(n, clauses);
  if (!fixed){
    setStatus('<span class="warn">Instance appears UNSAT for n ≤ 20 (no fixed solution found).</span>', false);
    fixed=null; working=null; renderClauses(); renderAssignments(); renderChain();
    btnStep.disabled=true; btnPlay.disabled=true; updateBadges(); updateProgressBar(); return;
  }
  setSeedDefault(); restartWorkingAssignment(true); dirty=false;
  btnStep.disabled=false; btnPlay.disabled=false; updateBadges(); updateProgressBar();
}

function playLoop(){
  if (!playing) return;
  doStep();
  const delay = parseInt(elSpeed.value,10)||240;
  timer = setTimeout(playLoop, delay);
}

// ---------- Events ----------
// Apply edits when closing the editor
btnDone.addEventListener('click', ()=>{ loadInstance(); editorPanel.classList.add('hidden'); });
btnStep.addEventListener('click', doStep);
btnPlay.addEventListener('click', ()=>{
  if (!fixed) return;
  playing = !playing;
  btnPlay.textContent = playing ? 'Pause' : 'Play';
  if (playing) playLoop();
});
btnRestart.addEventListener('click', ()=>{ setSeedDefault(); restartWorkingAssignment(true); });
btnToggleControls.addEventListener('click', ()=>{ editorPanel.classList.toggle('hidden'); });
btnDone.addEventListener('click', ()=>{ editorPanel.classList.add('hidden'); });

function markDirty(){
  dirty=true;
  if (playing){ playing=false; btnPlay.textContent='Play'; if (timer){ clearTimeout(timer); timer=null; } }
  btnStep.disabled=true; btnPlay.disabled=true; setPendingMessage(); editorPanel.classList.remove('hidden');
}
elCNF.addEventListener('input', markDirty);
elFixed.addEventListener('input', markDirty);
// Hide editor by default
editorPanel.classList.add('hidden');

// ---------- Default instance ----------
const defaultCNF =
`c Instance A (10 vars, 43 clauses) — satisfiable
p cnf 10 43
-3 5 -8 0
7 8 -10 0
6 8 -10 0
-1 -6 -7 0
-4 -6 -8 0
-1 -6 7 0
-2 4 -5 0
-1 4 10 0
-6 -7 -10 0
-4 6 -10 0
-1 -5 9 0
-1 -6 -8 0
-4 -7 8 0
-5 6 9 0
2 7 -8 0
-2 5 -7 0
-1 -2 7 0
-1 2 -3 0
1 3 -10 0
-5 6 -8 0
-1 2 5 0
-3 6 -8 0
-4 5 8 0
-1 -2 6 0
-2 6 -7 0
-2 6 -8 0
-2 -3 10 0
-1 -5 8 0
-4 -7 10 0
-1 3 -6 0
-5 7 -8 0
-1 4 -6 0
3 -7 -8 0
1 -7 -10 0
-1 -3 -7 0
-4 -7 -9 0
1 -4 -8 0
-2 5 10 0
-5 7 10 0
2 -3 8 0
-4 6 7 0
-2 -5 -8 0
-4 5 -9 0
`;
document.getElementById('cnfInput').value = defaultCNF;
document.getElementById('fixedInput').value = '0 0 1 0 0 0 0 1 0 0';
loadInstance();
</script>
