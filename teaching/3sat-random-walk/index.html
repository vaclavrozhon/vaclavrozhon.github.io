---
layout: single
title: Random Walk for 3SAT — Markov Chain Demo
permalink: "/teaching/3sat-random-walk/"
katex: false
---

<style>
.three-sat-container { max-width: 1000px; margin: 0 auto; }
.controls { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem; }
.controls textarea { width: 100%; min-height: 120px; font-family: monospace; }
.controls .field { display: flex; flex-direction: column; }
.status { margin: 0.5rem 0 1rem; font-size: 0.95rem; }
.status .ok { color: #2e7d32; }
.status .warn { color: #c62828; }
.status.pending { color: #6a1b9a; }
.viz { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-top: 12px; }
.clauses { display: flex; flex-wrap: wrap; gap: 8px; }
.clause { padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; font-family: monospace; }
.clause.sat { background:#e8f5e9; border-color:#a5d6a7; }
.clause.unsat { background:#ffebee; border-color:#ef9a9a; }
.clause.selected { box-shadow: 0 0 0 3px #ffd54f inset; }
.assignments { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; font-family: monospace; }
.assignment { padding: 4px 8px; border: 1px solid #ccc; border-radius: 6px; }
.assignment.fixed { background:#e3f2fd; border-color:#90caf9; }
.assignment.working { background:#f3e5f5; border-color:#ce93d8; }
.chain { margin-top: 16px; }
.chain svg { width: 100%; height: 140px; }
.controls-row { display:flex; align-items:center; gap:10px; flex-wrap: wrap; margin-top: 8px; }
.prob-label { font-size: 0.9rem; color: #555; }
.legend { font-size: 0.9rem; color: #555; margin-top: 8px; }
.small { font-size: 0.85rem; color: #666; }
button { cursor: pointer; }
</style>

<div class="three-sat-container">
  <h2>Random Walk for 3SAT</h2>
  <p class="small">Pick a random unsatisfied clause, then flip a uniformly random variable from it. Track agreement with a fixed satisfying assignment.</p>

  <div class="controls">
    <div class="field">
      <label for="cnfInput"><strong>DIMACS CNF</strong> (≤ 20 variables)</label>
      <textarea id="cnfInput"></textarea>
    </div>
    <div class="field">
      <label for="fixedInput"><strong>Fixed satisfying assignment</strong> (optional; 0/1 or ±1, space-separated). Leave empty to auto-solve.</label>
      <textarea id="fixedInput" placeholder="e.g. 1 0 1 1 0"></textarea>
    </div>
  </div>

  <div class="controls-row">
    <button id="btnParse">Load instance</button>
    <button id="btnStep">Step</button>
    <button id="btnPlay">Play</button>
    <button id="btnRestart">Restart</button>
    <button id="btnResetToFixed">Reset to fixed</button>
    <label class="small">Seed <input id="seedInput" type="text" value="" style="width:8rem"></label>
    <label class="small">Speed <input id="speedInput" type="range" min="50" max="1000" step="50" value="300"></label>
  </div>

  <div class="status" id="status"></div>

  <div class="viz">
    <div><strong>Clauses</strong></div>
    <div class="clauses" id="clauses"></div>
    <div class="assignments" id="assignments"></div>
  </div>

  <div class="viz chain">
    <div><strong>Agreement with fixed assignment</strong> (nodes 0..n)</div>
    <div class="prob-label" id="probLabel"></div>
    <svg id="chainSvg" viewBox="0 0 1000 140" preserveAspectRatio="none"></svg>
    <div class="legend small">After selecting a clause: left probability = k/3, right = (3−k)/3, where k is the number of literals in the chosen clause currently matching the fixed assignment.</div>
  </div>
</div>

<script>
// Utility: simple seeded RNG (Mulberry32)
function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function hashStringToSeed(str) {
  let h = 2166136261 >>> 0;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

// DIMACS parser (supports comments, p cnf n m, clauses ending with 0)
function parseDimacs(text) {
  const lines = text.split(/\r?\n/);
  const clauses = [];
  let declaredN = null, declaredM = null;
  for (const raw of lines) {
    const line = raw.trim();
    if (!line || line.startsWith('c')) continue;
    if (line.startsWith('p')) {
      const parts = line.split(/\s+/);
      if (parts.length >= 4 && parts[1].toLowerCase() === 'cnf') {
        declaredN = parseInt(parts[2], 10);
        declaredM = parseInt(parts[3], 10);
      }
      continue;
    }
    const nums = line.split(/\s+/).map(x => parseInt(x, 10)).filter(x => !Number.isNaN(x));
    let clause = [];
    for (const v of nums) {
      if (v === 0) break;
      clause.push(v);
    }
    if (clause.length > 0) clauses.push(clause);
  }
  // Infer n from largest var index in absolute value
  let n = 0;
  for (const c of clauses) for (const lit of c) n = Math.max(n, Math.abs(lit));
  if (declaredN !== null && declaredN !== n) n = Math.max(n, declaredN);
  if (declaredM !== null && declaredM !== clauses.length) {
    // not fatal; ignore count mismatch
  }
  return { n, clauses };
}

// Evaluate clause and formula under assignment (assignment is array of booleans length n)
function evalClause(clause, assignment) {
  for (const lit of clause) {
    const idx = Math.abs(lit) - 1;
    const isPos = lit > 0;
    const val = assignment[idx];
    if ((isPos && val) || (!isPos && !val)) return true;
  }
  return false;
}

function evalFormula(clauses, assignment) {
  return clauses.every(c => evalClause(c, assignment));
}

// Small backtracking SAT solver for n <= 20
function solveSAT(n, clauses) {
  const assignment = new Array(n).fill(false);
  function dfs(i) {
    if (i === n) return evalFormula(clauses, assignment) ? assignment.slice() : null;
    // simple unit-style pruning: if any clause becomes impossible (all literals false), prune
    for (let choice = 0; choice < 2; choice++) {
      assignment[i] = choice === 1;
      let ok = true;
      for (const cl of clauses) {
        let canBeTrue = false;
        for (const lit of cl) {
          const idx = Math.abs(lit) - 1;
          const isPos = lit > 0;
          const val = idx < i ? assignment[idx] : null; // unknown for idx >= i
          if (idx > i) { canBeTrue = true; break; }
          if ((isPos && val) || (!isPos && !val)) { canBeTrue = true; break; }
        }
        if (!canBeTrue) { ok = false; break; }
      }
      if (ok) {
        const res = dfs(i + 1);
        if (res) return res;
      }
    }
    return null;
  }
  return dfs(0);
}

function parseFixedAssignment(text, n) {
  if (!text || !text.trim()) return null;
  const toks = text.trim().split(/\s+/);
  if (toks.length < n) return null;
  const arr = [];
  for (let i = 0; i < n; i++) {
    const t = toks[i];
    if (t === '1' || t === '+1' || t === '+') arr.push(true);
    else if (t === '0' || t === '-1' || t === '-') arr.push(false);
    else return null;
  }
  return arr;
}

// Visualization and state
const elCNF = document.getElementById('cnfInput');
const elFixed = document.getElementById('fixedInput');
const elStatus = document.getElementById('status');
const elClauses = document.getElementById('clauses');
const elAssignments = document.getElementById('assignments');
const elProb = document.getElementById('probLabel');
const svg = document.getElementById('chainSvg');

const btnParse = document.getElementById('btnParse');
const btnStep = document.getElementById('btnStep');
const btnPlay = document.getElementById('btnPlay');
const btnRestart = document.getElementById('btnRestart');
const btnResetToFixed = document.getElementById('btnResetToFixed');
const elSeed = document.getElementById('seedInput');
const elSpeed = document.getElementById('speedInput');

let n = 0;
let clauses = [];
let fixed = null; // boolean[]
let working = null; // boolean[]
let rng = Math.random;
let playing = false;
let timer = null;
let substep = 0; // 0 = select clause, 1 = flip var
let selectedClauseIndex = -1;
let hammingAgree = 0; // number of variables matching fixed
let stepCount = 0;
let dirty = false; // inputs edited but not loaded

function setStatus(html, isOk) {
  elStatus.innerHTML = html;
  elStatus.className = 'status ' + (isOk ? 'ok' : 'warn');
}

function setPendingMessage() {
  elStatus.innerHTML = 'Changes pending. Click "Load instance" to apply.';
  elStatus.className = 'status pending';
}

function countAgree(a, b) {
  let h = 0; for (let i = 0; i < a.length; i++) if (a[i] === b[i]) h++; return h;
}

function renderAssignments() {
  elAssignments.innerHTML = '';
  if (!fixed || !working) return;
  for (let i = 0; i < n; i++) {
    const f = document.createElement('div');
    f.className = 'assignment fixed';
    f.textContent = `x${i+1}=${fixed[i]?1:0}`;
    elAssignments.appendChild(f);
  }
  for (let i = 0; i < n; i++) {
    const w = document.createElement('div');
    w.className = 'assignment working';
    w.textContent = `x${i+1}=${working[i]?1:0}`;
    elAssignments.appendChild(w);
  }
}

function renderClauses() {
  elClauses.innerHTML = '';
  const unsatisfied = [];
  for (let i = 0; i < clauses.length; i++) {
    const sat = evalClause(clauses[i], working);
    if (!sat) unsatisfied.push(i);
    const d = document.createElement('div');
    d.className = 'clause ' + (sat ? 'sat' : 'unsat') + (i === selectedClauseIndex ? ' selected' : '');
    d.textContent = '(' + clauses[i].map(l => l > 0 ? `x${l}` : `¬x${-l}`).join(' ∨ ') + ')';
    elClauses.appendChild(d);
  }
  return unsatisfied;
}

function renderChain() {
  svg.innerHTML = '';
  if (!fixed) return;
  const width = svg.viewBox.baseVal.width;
  const height = svg.viewBox.baseVal.height;
  const padding = 40;
  const nodeCount = n + 1;
  const usable = width - 2 * padding;
  const stepX = nodeCount > 1 ? usable / (nodeCount - 1) : 0;

  // draw axis
  const axis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  axis.setAttribute('x1', padding);
  axis.setAttribute('y1', 70);
  axis.setAttribute('x2', width - padding);
  axis.setAttribute('y2', 70);
  axis.setAttribute('stroke', '#999');
  svg.appendChild(axis);

  for (let i = 0; i < nodeCount; i++) {
    const cx = padding + i * stepX;
    const cy = 70;
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', cx);
    circle.setAttribute('cy', cy);
    circle.setAttribute('r', 14);
    circle.setAttribute('fill', i === hammingAgree ? '#1976d2' : '#eee');
    circle.setAttribute('stroke', '#666');
    svg.appendChild(circle);

    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('x', cx);
    label.setAttribute('y', cy + 32);
    label.setAttribute('text-anchor', 'middle');
    label.setAttribute('font-size', '12');
    label.textContent = i;
    svg.appendChild(label);
  }
}

function updateProbLabel(k) {
  if (k == null) { elProb.textContent = ''; return; }
  const left = `${k}/3 left`;
  const right = `${3 - k}/3 right`;
  elProb.textContent = `Transition probabilities: ${left}, ${right}`;
}

function selectUnsatisfiedClause() {
  const unsat = [];
  for (let i = 0; i < clauses.length; i++) if (!evalClause(clauses[i], working)) unsat.push(i);
  if (unsat.length === 0) return -1;
  const idx = Math.floor(rng() * unsat.length);
  return unsat[idx];
}

function substepSelectClause() {
  selectedClauseIndex = selectUnsatisfiedClause();
  if (selectedClauseIndex === -1) {
    setStatus('All clauses are satisfied. Reached a solution.', true);
    playing = false; btnPlay.textContent = 'Play';
    updateProbLabel(null);
    return;
  }
  const clause = clauses[selectedClauseIndex];
  let k = 0;
  for (const lit of clause) {
    const idx = Math.abs(lit) - 1;
    const matchesFixed = working[idx] === fixed[idx];
    if (matchesFixed) k++;
  }
  updateProbLabel(k);
  renderClauses();
}

function substepFlipVariable() {
  if (selectedClauseIndex < 0) return;
  const clause = clauses[selectedClauseIndex];
  const pick = clause[Math.floor(rng() * clause.length)];
  const vIdx = Math.abs(pick) - 1;
  const beforeMatch = working[vIdx] === fixed[vIdx];
  working[vIdx] = !working[vIdx];
  const afterMatch = working[vIdx] === fixed[vIdx];
  if (beforeMatch && !afterMatch) hammingAgree--;
  else if (!beforeMatch && afterMatch) hammingAgree++;
  stepCount++;
  selectedClauseIndex = -1;
  updateProbLabel(null);
  renderClauses();
  renderAssignments();
  renderChain();
}

function doStep() {
  if (substep === 0) { substepSelectClause(); substep = 1; }
  else { substepFlipVariable(); substep = 0; }
}

function setSeedFromInput() {
  const val = elSeed.value.trim();
  if (!val) { rng = Math.random; return; }
  const seed = /^\d+$/.test(val) ? parseInt(val, 10) : hashStringToSeed(val);
  rng = mulberry32(seed);
}

function restartWorkingAssignment(randomize = true) {
  if (!fixed) return;
  if (randomize) {
    working = new Array(n).fill(false).map(() => rng() < 0.5);
  } else {
    working = fixed.slice();
  }
  hammingAgree = countAgree(working, fixed);
  substep = 0; selectedClauseIndex = -1; stepCount = 0;
  renderAssignments();
  renderClauses();
  renderChain();
  setStatus(`Loaded n=${n}, clauses=${clauses.length}. Agreement h=${hammingAgree}/${n}.`, true);
}

function loadInstance() {
  const parsed = parseDimacs(elCNF.value);
  n = parsed.n; clauses = parsed.clauses;
  if (n <= 0 || n > 20) {
    setStatus('Invalid or too large instance. Require 1 ≤ n ≤ 20.', false);
    return;
  }
  // try fixed from textarea first
  const manual = parseFixedAssignment(elFixed.value, n);
  if (manual) fixed = manual; else fixed = solveSAT(n, clauses);
  if (!fixed) {
    setStatus('Instance appears UNSAT for n ≤ 20 (no fixed solution found).', false);
    fixed = null; working = null;
    renderClauses(); renderAssignments(); renderChain();
    btnStep.disabled = true; btnPlay.disabled = true;
    return;
  }
  setSeedFromInput();
  restartWorkingAssignment(true);
  dirty = false;
  btnStep.disabled = false; btnPlay.disabled = false;
}

function playLoop() {
  if (!playing) return;
  doStep();
  const delay = parseInt(elSpeed.value, 10) || 300;
  timer = setTimeout(playLoop, delay);
}

btnParse.addEventListener('click', () => { loadInstance(); });
btnStep.addEventListener('click', () => { doStep(); });
btnPlay.addEventListener('click', () => {
  if (!fixed) return;
  playing = !playing;
  btnPlay.textContent = playing ? 'Pause' : 'Play';
  if (playing) playLoop();
});
btnRestart.addEventListener('click', () => { setSeedFromInput(); restartWorkingAssignment(true); });
btnResetToFixed.addEventListener('click', () => { restartWorkingAssignment(false); });

// Mark inputs as dirty; require explicit Load to apply
function markDirty() {
  dirty = true;
  if (playing) { playing = false; btnPlay.textContent = 'Play'; if (timer) { clearTimeout(timer); timer = null; } }
  btnStep.disabled = true;
  btnPlay.disabled = true;
  setPendingMessage();
}
elCNF.addEventListener('input', markDirty);
elFixed.addEventListener('input', markDirty);

// Provide a small default instance
const defaultCNF = `c Small satisfiable 3-CNF\n`+
`p cnf 6 5\n`+
`1 -2 3 0\n`+
`-1 2 4 0\n`+
`-3 -4 5 0\n`+
`-2 -5 6 0\n`+
`-1 -3 -6 0\n`;
elCNF.value = defaultCNF;
elFixed.value = '';
loadInstance();
</script>


