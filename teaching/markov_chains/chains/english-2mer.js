class English2Mer extends MarkovChain {
    constructor() {
        // Initialize with empty data for simplified visualization
        // For 2-mer we'll show a subset since 582 states is too many to visualize
        super({
            name: "English 2-mer (Bigrams)",
            description: "Common English bigram transitions (subset for visualization)",
            states: [],
            stateNames: [],
            transitionMatrix: [],
            initialDistribution: [],
            colorScheme: 'gradient'
        });

        // Override the dots and stateCount that were initialized by the parent class
        // Keep them empty until data is loaded
        this.dots = [];
        this.stateCount = [];
        this.stepCount = 0;
        this.transitionCount = {};
        this._dataLoaded = false;
        this.generatedWords = [];  // Track words generated by dots

        // Absorption tracking - will be set after data loads
        this.absorbingStateIndex = null; // Will be set to </s> index
        this.dotArrivalSteps = [];
        this._absorbed = [];
        this.absorbedCount = 0;

        // Load and process data from CSV file
        this.loadFromCSV();
    }
    getNodeRadius() {
        // Smaller nodes for dense layout
        return 10;
    }


    async loadFromCSV() {
        try {
            const response = await fetch('markov_k2.csv');
            const csvText = await response.text();

            // Parse CSV
            const lines = csvText.trim().split('\n');

            // Build full transition map from CSV data
            const transitions = {};
            const statesSet = new Set();

            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(',');
                if (parts.length >= 4) {
                    const context = parts[1];
                    const next = parts[2];
                    const prob = parseFloat(parts[3]);

                    statesSet.add(context);
                    statesSet.add(next);

                    if (!transitions[context]) {
                        transitions[context] = {};
                    }
                    transitions[context][next] = prob;
                }
            }

            // Build complete bigram structure: <s><s>, <s>X, XY, X</s>, </s></s>
            const letters = 'abcdefghijklmnopqrstuvwxyz'.split('');
            const states = [];
            const stateNames = [];

            // 1. Start state: <s><s>
            states.push(0);
            stateNames.push('<s><s>');

            // 2. <s>X states (26 states)
            for (const letter of letters) {
                states.push(states.length);
                stateNames.push(`<s>${letter}`);
            }

            // 3. XY states (26x26 = 676 states)
            for (const first of letters) {
                for (const second of letters) {
                    states.push(states.length);
                    stateNames.push(`${first}${second}`);
                }
            }

            // 4. X</s> states (26 states)
            for (const letter of letters) {
                states.push(states.length);
                stateNames.push(`${letter}</s>`);
            }

            // 5. End state: </s></s>
            states.push(states.length);
            stateNames.push('</s></s>');

            // Total: 1 + 26 + 676 + 26 + 1 = 730 states

            // Build transition matrix
            const n = states.length;
            const matrix = Array(n).fill(null).map(() => Array(n).fill(0));

            for (let i = 0; i < n; i++) {
                const fromState = stateNames[i];

                if (fromState === '</s></s>') {
                    // Absorbing end state
                    matrix[i][i] = 1.0;
                } else if (fromState.endsWith('</s>') && fromState.length === 5) {
                    // X</s> states should transition to </s></s> with probability 1
                    // (since no such transitions exist in the training data)
                    const endStateIndex = stateNames.indexOf('</s></s>');
                    if (endStateIndex >= 0) {
                        matrix[i][endStateIndex] = 1.0;
                    }
                } else {
                    // Map internal state names to CSV format and build transitions
                    let csvFromState = fromState;

                    // Handle special mappings for CSV format
                    if (fromState.endsWith('</s>')) {
                        // X</s> states: map to single letter in CSV
                        csvFromState = fromState.substring(0, fromState.length - 4); // Remove '</s>'
                    }

                    if (transitions[csvFromState]) {
                        for (const [csvToState, prob] of Object.entries(transitions[csvFromState])) {
                            // Find the internal state that corresponds to this CSV transition
                            let targetStateIndex = -1;

                            if (fromState === '<s><s>' && csvToState !== '</s>') {
                                // <s><s> -> X should go to <s>X
                                const targetState = '<s>' + csvToState;
                                targetStateIndex = stateNames.indexOf(targetState);
                            } else if (fromState.startsWith('<s>') && fromState.length === 4) {
                                // <s>X -> Y should go to XY
                                const X = fromState[3]; // Get the X from <s>X
                                if (csvToState === '</s>') {
                                    // <s>X -> </s> should go to X</s>
                                    const targetState = X + '</s>';
                                    targetStateIndex = stateNames.indexOf(targetState);
                                } else {
                                    // <s>X -> Y should go to XY
                                    const targetState = X + csvToState;
                                    targetStateIndex = stateNames.indexOf(targetState);
                                }
                            } else if (fromState.length === 2 && !fromState.includes('<') && !fromState.includes('>')) {
                                // XY -> Z should go to YZ
                                const Y = fromState[1]; // Get the Y from XY
                                if (csvToState === '</s>') {
                                    // XY -> </s> should go to Y</s>
                                    targetStateIndex = stateNames.indexOf(Y + '</s>');
                                } else {
                                    const targetState = Y + csvToState;
                                    targetStateIndex = stateNames.indexOf(targetState);
                                }
                            } else if (fromState.endsWith('</s>') && csvToState === '</s>') {
                                // X</s> -> </s> should go to </s></s>
                                targetStateIndex = stateNames.indexOf('</s></s>');
                            }

                            if (targetStateIndex >= 0) {
                                matrix[i][targetStateIndex] = prob;
                            }
                        }
                    }
                }
            }



            // Update the chain properties
            this.states = states;
            this.stateNames = stateNames;
            this.transitionMatrix = matrix;
            this.stateCount = new Array(n).fill(0);
            this.initialDistribution = Array(n).fill(0);

            // Start at <s><s>
            this.initialDistribution[0] = 1.0;

            // Set absorption tracking for </s> state
            const endStateIndex = stateNames.indexOf('</s>');
            if (endStateIndex !== -1) {
                this.absorbingStateIndex = endStateIndex;
                this.onArrival = (dotIndex, state) => {
                    if (state === this.absorbingStateIndex && !this._absorbed[dotIndex]) {
                        this._absorbed[dotIndex] = true;
                        this.absorbedCount++;
                        const dot = this.dots[dotIndex];
                        const transitions = dot.history ? dot.history.length - 1 : 0;
                        this.dotArrivalSteps[dotIndex] = transitions;
                    }
                };
            }

            // Clear any existing dots and reinitialize with new state count
            this.dots = [];
            this._dataLoaded = true;
            this.initializeDots();

            // Initialize absorption tracking arrays
            this.dotArrivalSteps = new Array(this.numDots).fill(NaN);
            this._absorbed = new Array(this.numDots).fill(false);
            this.absorbedCount = 0;

            // Trigger re-render if needed
            if (this.onDataLoaded) {
                this.onDataLoaded();
            }

        } catch (error) {
            console.error('Failed to load English 2-mer data:', error);
        }
    }

    initializeDots() {
        // Don't initialize dots until data is loaded
        if (!this._dataLoaded) {
            this.dots = [];
            this.stateCount = [];
            return;
        }
        // Call parent implementation when data is ready
        super.initializeDots();

        // Initialize word tracking for each dot
        for (let dot of this.dots) {
            dot.currentWord = '';  // Track the word being built
            dot.hasFinished = false;  // Track if dot has reached </s></s>
            dot.lastProcessedState = dot.currentState; // Track which state we last processed for this dot
        }
    }

    step() {
        // Call parent step method
        super.step();

        // Track word generation for 2-mer - only when dots change states
        for (let dot of this.dots) {
            if (dot.hasFinished) continue;

            // Only process if the dot has actually moved to a different state
            if (dot.currentState !== dot.lastProcessedState) {
                const currentStateName = this.stateNames[dot.currentState];

                if (currentStateName === '</s></s>') {
                    // Dot has finished - save the word if it's not empty
                    if (dot.currentWord.length > 0) {
                        this.generatedWords.push(dot.currentWord);
                    }
                    dot.hasFinished = true;
                } else if (currentStateName === '<s><s>') {
                    // Starting state - reset word
                    dot.currentWord = '';
                } else if (currentStateName.startsWith('<s>') && currentStateName.length === 4) {
                    // <s>X state - start building word with the letter
                    dot.currentWord = currentStateName.substring(3); // Remove '<s>', get the letter
                } else if (currentStateName.length === 2 && !currentStateName.includes('<') && !currentStateName.includes('>')) {
                    // XY state - add the second letter
                    dot.currentWord += currentStateName[1];
                }
                // Note: X</s> states don't add letters - the final letter was already added by the previous XY state

                // Update the last processed state
                dot.lastProcessedState = dot.currentState;
            }
        }
    }

    reset() {
        super.reset();
        this.generatedWords = [];
        // Reset word tracking for all dots
        for (let dot of this.dots) {
            dot.currentWord = '';
            dot.hasFinished = false;
            dot.lastProcessedState = dot.currentState; // Reset tracking
        }
    }

    getNodePositions(centerX, centerY, radius, canvasWidth) {
        // Custom layout: <s><s> left, <s>X column, XY matrix, X</s> column, </s></s> right
        const positions = [];
        // Calculate required dimensions to accommodate 26x26 matrix with 40px spacing (smaller nodes)
        const minMatrixWidth = 26 * 40; // 1040px minimum for matrix
        const minMatrixHeight = 26 * 40; // 1040px minimum for matrix
        const minTotalWidth = minMatrixWidth + 600; // Add space for columns and margins
        const minTotalHeight = Math.max(minMatrixHeight + 200, 1500); // Add space for margins

        const width = Math.max((canvasWidth || 800) * 2.5, minTotalWidth);
        const height = minTotalHeight;

        if (this.stateNames.length === 0) {
            return positions;
        }

        // The radius parameter seems to be passed incorrectly (240px), so use reasonable value
        const nodeRadius = 10; // Smaller radius to avoid overlap in dense grid
        const clearanceGap = 6; // Minimum gap between node edges
        const minNodeSpacing = nodeRadius * 2 + clearanceGap; // 26px spacing

        // console.log(`DEBUG POSITIONING: width=${width}, height=${height}, nodeRadius=${nodeRadius}, minNodeSpacing=${minNodeSpacing}`);

        // 1. <s><s> on far left edge (aligned with canvas edge)
        positions.push({
            x: nodeRadius + 5, // Dynamic: just enough to not clip the edge
            y: height / 2
        });

        // 2. <s>X column (26 states) - vertical column with proper spacing
        const colX = width * 0.12;
        const verticalMargin = nodeRadius + 40; // Dynamic margin based on radius
        const colHeight = height - 2 * verticalMargin;
        const letterSpacing = Math.max(colHeight / 25, minNodeSpacing);
        const colStartY = (height - letterSpacing * 25) / 2;

        // console.log(`DEBUG COLUMN: colX=${colX}, colHeight=${colHeight}, letterSpacing=${letterSpacing}, colStartY=${colStartY}`);

        for (let i = 0; i < 26; i++) {
            positions.push({
                x: colX,
                y: colStartY + i * letterSpacing
            });
        }

        // 3. XY matrix (26x26 = 676 states) - arranged in grid with proper spacing
        const matrixStartX = width * 0.22;
        const matrixEndX = width * 0.78;
        const matrixWidth = matrixEndX - matrixStartX;
        const matrixStartY = verticalMargin; // Use same dynamic margin
        const matrixHeight = height - 2 * verticalMargin;

        // CRITICAL: Enforce minimum cell size to prevent node overlap
        // For neighboring nodes not to overlap: cellWidth >= 2*nodeRadius + gap
        // We use minNodeSpacing = 2*nodeRadius + gap = 80px
        const minCellSize = minNodeSpacing; // enforce non-overlap
        const cellWidth = Math.max(matrixWidth / 26, minCellSize);
        const cellHeight = Math.max(matrixHeight / 26, minCellSize);

        // If the matrix needs more space than allocated, it will expand beyond the allocated area
        // This is correct behavior - we prioritize non-overlapping nodes over fitting in arbitrary bounds

        // Center the matrix if it's smaller than available space
        const actualMatrixWidth = cellWidth * 26;
        const actualMatrixHeight = cellHeight * 26;
        const adjustedMatrixStartX = matrixStartX + (matrixWidth - actualMatrixWidth) / 2;
        const adjustedMatrixStartY = matrixStartY + (matrixHeight - actualMatrixHeight) / 2;

        for (let row = 0; row < 26; row++) {
            for (let col = 0; col < 26; col++) {
                positions.push({
                    x: adjustedMatrixStartX + col * cellWidth + cellWidth / 2,
                    y: adjustedMatrixStartY + row * cellHeight + cellHeight / 2
                });
            }
        }

        // 4. X</s> column (26 states) - vertical column on right with same spacing as left column
        const rightColX = width * 0.88;
        for (let i = 0; i < 26; i++) {
            positions.push({
                x: rightColX,
                y: colStartY + i * letterSpacing
            });
        }

        // 5. </s></s> on far right
        positions.push({
            x: width * 0.95,
            y: height / 2
        });

        return positions;
    }

    getStateColor(stateIndex) {
        // Color coding for different types of states
        if (stateIndex === 0) {
            return '#FF6B6B'; // <s><s> - red
        }

        if (stateIndex < 27) {
            // <s>X states - blue gradient
            const intensity = 0.7 + 0.3 * (stateIndex - 1) / 25;
            return `hsl(220, 70%, ${50 + intensity * 20}%)`;
        }

        if (stateIndex < 27 + 676) {
            // XY states - green gradient based on position
            const pos = stateIndex - 27;
            const row = Math.floor(pos / 26);
            const col = pos % 26;
            const hue = 120 + (row + col) * 2; // Green with slight variation
            return `hsl(${hue % 360}, 60%, 55%)`;
        }

        if (stateIndex < 27 + 676 + 26) {
            // X</s> states - orange gradient
            const pos = stateIndex - 27 - 676;
            const intensity = 0.7 + 0.3 * pos / 25;
            return `hsl(30, 70%, ${50 + intensity * 20}%)`;
        }

        // </s></s> - gray
        return '#808080';
    }

    getTheoreticalSteadyState() {
        // With absorbing end state
        const n = this.states.length;
        const steadyState = Array(n).fill(0);

        // Find the end state
        const endIndex = this.stateNames.findIndex(name =>
            name.includes('</s>') || name === 'END'
        );

        if (endIndex >= 0) {
            steadyState[endIndex] = 1.0;
        }

        return steadyState;
    }

    getGeneratedWords() {
        return this.generatedWords || [];
    }

    getRenderConfig() {
        return {
            showTransitionMatrix: false,
            canvasHeight: 1000,
            showEdgeLabels: false
        };
    }

    isRunComplete() {
        return this.absorbedCount === this.numDots;
    }

    getHistogramData() {
        return this.dotArrivalSteps ? this.dotArrivalSteps.filter(v => Number.isFinite(v)) : [];
    }

    reset() {
        super.reset();
        this.dotArrivalSteps = new Array(this.numDots).fill(NaN);
        this._absorbed = new Array(this.numDots).fill(false);
        this.absorbedCount = 0;
    }

    setNumDots(num) {
        super.setNumDots(num);
        this.dotArrivalSteps = new Array(num).fill(NaN);
        this._absorbed = new Array(num).fill(false);
        this.absorbedCount = 0;
    }
}

chainModules.push(English2Mer);